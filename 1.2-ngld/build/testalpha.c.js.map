{"version":3,"file":"testalpha.c.js","sources":["../SDL-1.2.15/testalpha.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqVA;AAAA;AAAA;AAAA;;;AAuHA;;AA7GA;AACA;AAEA;AAAA;AACA;;AACA;;AAEA;AACA;AAAA;;AAEA;AACA;AAAA;;;;;AAKA;;;;;;AAHA;AAAA;AAAA;AAAA;;;;;AAEA;AACA;;;;AAIA;;;;;AAGA;;;;;;AAEA;AAAA;;;;AACA;AAAA;;;;;;;AAEA;AAAA;;;;AACA;AAAA;;;;;;AAGA;;;;;AAGA;;;;;;;;AAGA;;;;AA3BA;AAAA;AAAA;;;;;;;;;;AA6BA;AAAA;AAAA;AAGA;;;;;;;;AAKA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;AAEA;AAGA;AAAA;;AAEA;;;;AAKA;AACA;;;AAIA;AAAA;;AAEA;;AAEA;;;AAGA;;;AAGA;;AAEA;;AAIA;;AAIA;;AAFA;;AAOA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;;;AACA;;;;;;AAlXA;AAAA;;AAGA;AAAA;AAAA;AAAA;;;AA2DA;;AArDA;AAAA;AAAA;AAAA;AAIA;AAAA;AAGA;AACA;AAAA;;;AAIA;;;;;;;;;;AAFA;AAAA;AADA;AAAA;;;;;;;;;;;;;;;;AADA;;;;;;;;;;;;;AAsCA;;;;;;;;;;;;;;;AAtBA;AACA;AACA;AAAA;;;;;AAOA;;;;;;;;AAWA;AAAA;AAtBA;AAAA;AAGA;;;;;;;;;;;;;;;;;;;AAJA;AAAA;;;;;;;;;;;;;AA4BA;;;AAIA;;;;;;;AA0TA;;AAGA;;AAHA;AACA;;;;AA6CA;AACA;AACA;AACA;;AA1BA;;;AAEA;AAAA;;;;AAEA;;;;;AAMA;AA5PA;AACA;AA6PA;;AAKA;;AAAA;AAnQA;AACA;AAoQA;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;AAQA;;AACA;;;;;AAEA;AAAA;AACA;AAAA;;;;AAMA;;AAMA;;;;;;;AAVA;AACA;AAAA;AAAA;AACA;;;;;;;AAgCA;AACA;AACA;AAGA;;AACA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;AA7TA;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;;;;AAWA;AACA;AA7GA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAsGA;AAAA;AAAA;AAAA;;;;;;;;;AAEA;AACA;;AAEA;AAAA;AAAA;AAAA;;;;;;;;;AAEA;AACA;;AAIA;AAAA;AACA;AAAA;;;AACA;AAAA;;;;;;;AAGA;AAAA;;;;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AAGA;;;;;;;;;AArHA;AAAA;;AAEA;AAAA;AAAA;AAAA;;;AAmDA;;;;;AA7CA;AAAA;;;AAKA;AACA;;AAEA;AACA;AAAA;AAAA;;;AAoCA;;AAjCA;AAGA;AAAA;;AAGA;AACA;AAAA;AAAA;AACA;;;AAyBA;;AApBA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;;;AAeA;;AAZA;AAGA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;AAIA;;;;;;;;;AA9MA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AAAA;AAAA;AAQA;AAAA;AAAA;;;AAYA;AACA;;;;AAnBA;AACA;;;;;;AADA;AADA;AAAA;;;;;;;;;AAmBA;AACA;;;;;AADA;AACA;;;;AATA;AAIA;;;;;;AAPA;AACA;AACA;;;;AAGA;AAFA;;;AAJA;AAAA;;;;;;;;;AAYA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAzCA;AACA","sourcesContent":["\n/* Simple program:  Fill a colormap with gray and stripe it down the screen,\n\t\t    Then move an alpha valued sprite around the screen.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"SDL.h\"\n\n#ifdef EMSCRIPTEN\n    #include <emscripten.h>\n    void main_loop();\n#endif\n\n#define FRAME_TICKS\t(1000/30)\t\t/* 30 frames/second */\n\n/* Call this instead of exit(), so we can clean up SDL: atexit() is evil. */\nstatic void quit(int rc)\n{\n\tSDL_Quit();\n\texit(rc);\n}\n\n/* Fill the screen with a gradient */\nstatic void FillBackground(SDL_Surface *screen)\n{\n\tUint8 *buffer;\n\tUint16 *buffer16;\n        Uint16 color;\n        Uint8  gradient;\n\tint    i, k;\n\n\t/* Set the surface pixels and refresh! */\n\tif ( SDL_LockSurface(screen) < 0 ) {\n\t\tfprintf(stderr, \"Couldn't lock the display surface: %s\\n\",\n\t\t\t\t\t\t\tSDL_GetError());\n\t\tquit(2);\n\t}\n\tbuffer=(Uint8 *)screen->pixels;\n\tif (screen->format->BytesPerPixel!=2) {\n\t\tfor ( i=0; i<screen->h; ++i ) {\n\t\t\tmemset(buffer,(i*255)/screen->h, screen->w*screen->format->BytesPerPixel);\n\t\t\tbuffer += screen->pitch;\n\t\t}\n\t}\n        else\n        {\n\t\tfor ( i=0; i<screen->h; ++i ) {\n\t\t\tgradient=((i*255)/screen->h);\n                        color = (Uint16)SDL_MapRGB(screen->format, gradient, gradient, gradient);\n                        buffer16=(Uint16*)buffer;\n                        for (k=0; k<screen->w; k++)\n                        {\n                            *(buffer16+k)=color;\n                        }\n\t\t\tbuffer += screen->pitch;\n\t\t}\n        }\n\n\tSDL_UnlockSurface(screen);\n\tSDL_UpdateRect(screen, 0, 0, 0, 0);\n}\n\n/* Create a \"light\" -- a yellowish surface with variable alpha */\nSDL_Surface *CreateLight(int radius)\n{\n\tUint8  trans, alphamask;\n\tint    range, addition;\n\tint    xdist, ydist;\n\tUint16 x, y;\n\tUint16 skip;\n\tUint32 pixel;\n\tSDL_Surface *light;\n\n#ifdef LIGHT_16BIT\n\tUint16 *buf;\n\n\t/* Create a 16 (4/4/4/4) bpp square with a full 4-bit alpha channel */\n\t/* Note: this isn't any faster than a 32 bit alpha surface */\n\talphamask = 0x0000000F;\n\tlight = SDL_CreateRGBSurface(SDL_SWSURFACE, 2*radius, 2*radius, 16,\n\t\t\t0x0000F000, 0x00000F00, 0x000000F0, alphamask);\n#else\n\tUint32 *buf;\n\n\t/* Create a 32 (8/8/8/8) bpp square with a full 8-bit alpha channel */\n\talphamask = 0x000000FF;\n\tlight = SDL_CreateRGBSurface(SDL_SWSURFACE, 2*radius, 2*radius, 32,\n\t\t\t0xFF000000, 0x00FF0000, 0x0000FF00, alphamask);\n\tif ( light == NULL ) {\n\t\tfprintf(stderr, \"Couldn't create light: %s\\n\", SDL_GetError());\n\t\treturn(NULL);\n\t}\n#endif\n\n\t/* Fill with a light yellow-orange color */\n\tskip = light->pitch-(light->w*light->format->BytesPerPixel);\n#ifdef LIGHT_16BIT\n\tbuf = (Uint16 *)light->pixels;\n#else\n\tbuf = (Uint32 *)light->pixels;\n#endif\n        /* Get a tranparent pixel value - we'll add alpha later */\n\tpixel = SDL_MapRGBA(light->format, 0xFF, 0xDD, 0x88, 0);\n\tfor ( y=0; y<light->h; ++y ) {\n\t\tfor ( x=0; x<light->w; ++x ) {\n\t\t\t*buf++ = pixel;\n\t\t}\n\t\tbuf += skip;\t/* Almost always 0, but just in case... */\n\t}\n\n\t/* Calculate alpha values for the surface. */\n#ifdef LIGHT_16BIT\n\tbuf = (Uint16 *)light->pixels;\n#else\n\tbuf = (Uint32 *)light->pixels;\n#endif\n\tfor ( y=0; y<light->h; ++y ) {\n\t\tfor ( x=0; x<light->w; ++x ) {\n\t\t\t/* Slow distance formula (from center of light) */\n\t\t\txdist = x-(light->w/2);\n\t\t\tydist = y-(light->h/2);\n\t\t\trange = (int)sqrt(xdist*xdist+ydist*ydist);\n\n\t\t\t/* Scale distance to range of transparency (0-255) */\n\t\t\tif ( range > radius ) {\n\t\t\t\ttrans = alphamask;\n\t\t\t} else {\n\t\t\t\t/* Increasing transparency with distance */\n\t\t\t\ttrans = (Uint8)((range*alphamask)/radius);\n\n\t\t\t\t/* Lights are very transparent */\n\t\t\t\taddition = (alphamask+1)/8;\n\t\t\t\tif ( (int)trans+addition > alphamask ) {\n\t\t\t\t\ttrans = alphamask;\n\t\t\t\t} else {\n\t\t\t\t\ttrans += addition;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* We set the alpha component as the right N bits */\n\t\t\t*buf++ |= (255-trans);\n\t\t}\n\t\tbuf += skip;\t/* Almost always 0, but just in case... */\n\t}\n\t/* Enable RLE acceleration of this alpha surface */\n\tSDL_SetAlpha(light, SDL_SRCALPHA|SDL_RLEACCEL, 0);\n\n\t/* We're done! */\n\treturn(light);\n}\n\nstatic Uint32 flashes = 0;\nstatic Uint32 flashtime = 0;\n\nvoid FlashLight(SDL_Surface *screen, SDL_Surface *light, int x, int y)\n{\n\tSDL_Rect position;\n\tUint32   ticks1;\n\tUint32   ticks2;\n\n\t/* Easy, center light */\n\tposition.x = x-(light->w/2);\n\tposition.y = y-(light->h/2);\n\tposition.w = light->w;\n\tposition.h = light->h;\n\tticks1 = SDL_GetTicks();\n\tSDL_BlitSurface(light, NULL, screen, &position);\n\tticks2 = SDL_GetTicks();\n\tSDL_UpdateRects(screen, 1, &position);\n\t++flashes;\n\n\t/* Update time spend doing alpha blitting */\n\tflashtime += (ticks2-ticks1);\n}\n\nstatic int sprite_visible = 0;\nstatic SDL_Surface *sprite;\nstatic SDL_Surface *backing;\nstatic SDL_Rect    position;\nstatic int         x_vel, y_vel;\nstatic int\t   alpha_vel;\n\nint LoadSprite(SDL_Surface *screen, char *file)\n{\n\tSDL_Surface *converted;\n\n\t/* Load the sprite image */\n\tsprite = SDL_LoadBMP(file);\n\tif ( sprite == NULL ) {\n\t\tfprintf(stderr, \"Couldn't load %s: %s\", file, SDL_GetError());\n\t\treturn(-1);\n\t}\n\n\t/* Set transparent pixel as the pixel at (0,0) */\n\tif ( sprite->format->palette ) {\n\t\tSDL_SetColorKey(sprite, SDL_SRCCOLORKEY,\n\t\t\t\t\t\t*(Uint8 *)sprite->pixels);\n\t}\n\n\t/* Convert sprite to video format */\n\tconverted = SDL_DisplayFormat(sprite);\n\tSDL_FreeSurface(sprite);\n\tif ( converted == NULL ) {\n\t\tfprintf(stderr, \"Couldn't convert background: %s\\n\",\n\t\t\t\t\t\t\tSDL_GetError());\n\t\treturn(-1);\n\t}\n\tsprite = converted;\n\n\t/* Create the background */\n\tbacking = SDL_CreateRGBSurface(SDL_SWSURFACE, sprite->w, sprite->h, 8,\n\t\t\t\t\t\t\t\t0, 0, 0, 0);\n\tif ( backing == NULL ) {\n\t\tfprintf(stderr, \"Couldn't create background: %s\\n\",\n\t\t\t\t\t\t\tSDL_GetError());\n\t\tSDL_FreeSurface(sprite);\n\t\treturn(-1);\n\t}\n\n\t/* Convert background to video format */\n\tconverted = SDL_DisplayFormat(backing);\n\tSDL_FreeSurface(backing);\n\tif ( converted == NULL ) {\n\t\tfprintf(stderr, \"Couldn't convert background: %s\\n\",\n\t\t\t\t\t\t\tSDL_GetError());\n\t\tSDL_FreeSurface(sprite);\n\t\treturn(-1);\n\t}\n\tbacking = converted;\n\n\t/* Set the initial position of the sprite */\n\tposition.x = (screen->w-sprite->w)/2;\n\tposition.y = (screen->h-sprite->h)/2;\n\tposition.w = sprite->w;\n\tposition.h = sprite->h;\n\tx_vel = 0; y_vel = 0;\n\talpha_vel = 1;\n\n\t/* We're ready to roll. :) */\n\treturn(0);\n}\n\nvoid AttractSprite(Uint16 x, Uint16 y)\n{\n\tx_vel = ((int)x-position.x)/10;\n\ty_vel = ((int)y-position.y)/10;\n}\n\nvoid MoveSprite(SDL_Surface *screen, SDL_Surface *light)\n{\n\tSDL_Rect updates[2];\n\tint alpha;\n\n\t/* Erase the sprite if it was visible */\n\tif ( sprite_visible ) {\n\t\tupdates[0] = position;\n\t\tSDL_BlitSurface(backing, NULL, screen, &updates[0]);\n\t} else {\n\t\tupdates[0].x = 0; updates[0].y = 0;\n\t\tupdates[0].w = 0; updates[0].h = 0;\n\t\tsprite_visible = 1;\n\t}\n\n\t/* Since the sprite is off the screen, we can do other drawing\n\t   without being overwritten by the saved area behind the sprite.\n\t */\n\tif ( light != NULL ) {\n\t\tint x, y;\n\n\t\tSDL_GetMouseState(&x, &y);\n\t\tFlashLight(screen, light, x, y);\n\t}\n\t   \n\t/* Move the sprite, bounce at the wall */\n\tposition.x += x_vel;\n\tif ( (position.x < 0) || (position.x >= screen->w) ) {\n\t\tx_vel = -x_vel;\n\t\tposition.x += x_vel;\n\t}\n\tposition.y += y_vel;\n\tif ( (position.y < 0) || (position.y >= screen->h) ) {\n\t\ty_vel = -y_vel;\n\t\tposition.y += y_vel;\n\t}\n\n\t/* Update transparency (fade in and out) */\n\talpha = sprite->format->alpha;\n\tif ( (alpha+alpha_vel) < 0 ) {\n\t\talpha_vel = -alpha_vel;\n\t} else\n\tif ( (alpha+alpha_vel) > 255 ) {\n\t\talpha_vel = -alpha_vel;\n\t}\n\tSDL_SetAlpha(sprite, SDL_SRCALPHA, (Uint8)(alpha+alpha_vel));\n\n\t/* Save the area behind the sprite */\n\tupdates[1] = position;\n\tSDL_BlitSurface(screen, &updates[1], backing, NULL);\n\t\n\t/* Blit the sprite onto the screen */\n\tupdates[1] = position;\n\tSDL_BlitSurface(sprite, NULL, screen, &updates[1]);\n\n\t/* Make it so! */\n\tSDL_UpdateRects(screen, 2, updates);\n}\n\nvoid WarpSprite(SDL_Surface *screen, int x, int y)\n{\n\tSDL_Rect updates[2];\n\n\t/* Erase, move, Draw, update */\n\tupdates[0] = position;\n\tSDL_BlitSurface(backing, NULL, screen, &updates[0]);\n\tposition.x = x-sprite->w/2;\t/* Center about X */\n\tposition.y = y-sprite->h/2;\t/* Center about Y */\n\tupdates[1] = position;\n\tSDL_BlitSurface(screen, &updates[1], backing, NULL);\n\tupdates[1] = position;\n\tSDL_BlitSurface(sprite, NULL, screen, &updates[1]);\n\tSDL_UpdateRects(screen, 2, updates);\n}\n\nint mouse_pressed;\nUint32 ticks, lastticks;\nint    w, h;\nSDL_Surface *screen;\nUint32 videoflags;\nint    i, done;\nSDL_Event event;\nconst SDL_VideoInfo *info;\nUint8  video_bpp;\nSDL_Surface *light;\n\nint main(int argc, char *argv[])\n{\n\t/* Initialize SDL */\n\tif ( SDL_Init(SDL_INIT_VIDEO) < 0 ) {\n\t\tfprintf(stderr, \"Couldn't initialize SDL: %s\\n\",SDL_GetError());\n\t\treturn(1);\n\t}\n\n\t/* Alpha blending doesn't work well at 8-bit color */\n#ifdef _WIN32_WCE\n\t/* Pocket PC */\n\tw = 240;\n\th = 320;\n#else\n\tw = 640;\n\th = 480;\n#endif\n\tinfo = SDL_GetVideoInfo();\n\tif ( info->vfmt->BitsPerPixel > 8 ) {\n\t\tvideo_bpp = info->vfmt->BitsPerPixel;\n\t} else {\n\t\tvideo_bpp = 16;\n                fprintf(stderr, \"forced 16 bpp mode\\n\");\n\t}\n\tvideoflags = SDL_SWSURFACE;\n\tfor ( i = 1; argv[i]; ++i ) {\n\t\tif ( strcmp(argv[i], \"-bpp\") == 0 ) {\n\t\t\tvideo_bpp = atoi(argv[++i]);\n                        if (video_bpp<=8) {\n                            video_bpp=16;\n                            fprintf(stderr, \"forced 16 bpp mode\\n\");\n                        }\n\t\t} else\n\t\tif ( strcmp(argv[i], \"-hw\") == 0 ) {\n\t\t\tvideoflags |= SDL_HWSURFACE;\n\t\t} else\n\t\tif ( strcmp(argv[i], \"-warp\") == 0 ) {\n\t\t\tvideoflags |= SDL_HWPALETTE;\n\t\t} else\n\t\tif ( strcmp(argv[i], \"-width\") == 0 && argv[i+1] ) {\n\t\t\tw = atoi(argv[++i]);\n\t\t} else\n\t\tif ( strcmp(argv[i], \"-height\") == 0 && argv[i+1] ) {\n\t\t\th = atoi(argv[++i]);\n\t\t} else\n\t\tif ( strcmp(argv[i], \"-resize\") == 0 ) {\n\t\t\tvideoflags |= SDL_RESIZABLE;\n\t\t} else\n\t\tif ( strcmp(argv[i], \"-noframe\") == 0 ) {\n\t\t\tvideoflags |= SDL_NOFRAME;\n\t\t} else\n\t\tif ( strcmp(argv[i], \"-fullscreen\") == 0 ) {\n\t\t\tvideoflags |= SDL_FULLSCREEN;\n\t\t} else {\n\t\t\tfprintf(stderr, \n\t\t\t\"Usage: %s [-width N] [-height N] [-bpp N] [-warp] [-hw] [-fullscreen]\\n\",\n\t\t\t\t\t\t\t\targv[0]);\n\t\t\tquit(1);\n\t\t}\n\t}\n\n\t/* Set video mode */\n\tif ( (screen=SDL_SetVideoMode(w,h,video_bpp,videoflags)) == NULL ) {\n\t\tfprintf(stderr, \"Couldn't set %dx%dx%d video mode: %s\\n\",\n\t\t\t\t\t\tw, h, video_bpp, SDL_GetError());\n\t\tquit(2);\n\t}\n\tFillBackground(screen);\n\n\t/* Create the light */\n\tlight = CreateLight(82);\n\tif ( light == NULL ) {\n\t\tquit(1);\n\t}\n\n\t/* Load the sprite */\n\tif ( LoadSprite(screen, \"icon.bmp\") < 0 ) {\n\t\tSDL_FreeSurface(light);\n\t\tquit(1);\n\t}\n\n\t/* Print out information about our surfaces */\n\tprintf(\"Screen is at %d bits per pixel\\n\",screen->format->BitsPerPixel);\n\tif ( (screen->flags & SDL_HWSURFACE) == SDL_HWSURFACE ) {\n\t\tprintf(\"Screen is in video memory\\n\");\n\t} else {\n\t\tprintf(\"Screen is in system memory\\n\");\n\t}\n\tif ( (screen->flags & SDL_DOUBLEBUF) == SDL_DOUBLEBUF ) {\n\t\tprintf(\"Screen has double-buffering enabled\\n\");\n\t}\n\tif ( (sprite->flags & SDL_HWSURFACE) == SDL_HWSURFACE ) {\n\t\tprintf(\"Sprite is in video memory\\n\");\n\t} else {\n\t\tprintf(\"Sprite is in system memory\\n\");\n\t}\n\n\t/* Run a sample blit to trigger blit acceleration */\n\tMoveSprite(screen, NULL);\n\tif ( (sprite->flags & SDL_HWACCEL) == SDL_HWACCEL ) {\n\t\tprintf(\"Sprite blit uses hardware alpha acceleration\\n\");\n\t} else {\n\t\tprintf(\"Sprite blit dosn't uses hardware alpha acceleration\\n\");\n\t}\n\n\t/* Set a clipping rectangle to clip the outside edge of the screen */\n\t{ SDL_Rect clip;\n\t\tclip.x = 32;\n\t\tclip.y = 32;\n\t\tclip.w = screen->w-(2*32);\n\t\tclip.h = screen->h-(2*32);\n\t\tSDL_SetClipRect(screen, &clip);\n\t}\n\n\t/* Wait for a keystroke */\n\tlastticks = SDL_GetTicks();\n\tdone = 0;\n\tmouse_pressed = 0;\n#ifndef EMSCRIPTEN\n\twhile ( !done ) {\n#else\n\temscripten_run_script(\"report(true);\");\n\temscripten_set_main_loop(&main_loop, 30, 1);\n}\n\nvoid main_loop() {\n#endif\n\t\t/* Update the frame -- move the sprite */\n\t\tif ( mouse_pressed ) {\n\t\t\tMoveSprite(screen, light);\n\t\t\tmouse_pressed = 0;\n\t\t} else {\n\t\t\tMoveSprite(screen, NULL);\n\t\t}\n\n#ifndef EMSCRIPTEN\n\t\t/* Slow down the loop to 30 frames/second */\n\t\tticks = SDL_GetTicks();\n\t\tif ( (ticks-lastticks) < FRAME_TICKS ) {\n#ifdef CHECK_SLEEP_GRANULARITY\nfprintf(stderr, \"Sleeping %d ticks\\n\", FRAME_TICKS-(ticks-lastticks));\n#endif\n\t\t\tSDL_Delay(FRAME_TICKS-(ticks-lastticks));\n#ifdef CHECK_SLEEP_GRANULARITY\nfprintf(stderr, \"Slept %d ticks\\n\", (SDL_GetTicks()-ticks));\n#endif\n\t\t}\n\t\tlastticks = ticks;\n#endif\n\n\t\t/* Check for events */\n\t\twhile ( SDL_PollEvent(&event) ) {\n\t\t\tswitch (event.type) {\n\t\t\t\tcase SDL_VIDEORESIZE:\n\t\t\t\t\tscreen = SDL_SetVideoMode(event.resize.w, event.resize.h, video_bpp, videoflags);\n\t\t\t\t\tif ( screen ) {\n\t\t\t\t\t\tFillBackground(screen);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t/* Attract sprite while mouse is held down */\n\t\t\t\tcase SDL_MOUSEMOTION:\n\t\t\t\t\tif (event.motion.state != 0) {\n\t\t\t\t\t\tAttractSprite(event.motion.x,\n\t\t\t\t\t\t\t\tevent.motion.y);\n\t\t\t\t\t\tmouse_pressed = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SDL_MOUSEBUTTONDOWN:\n\t\t\t\t\tif ( event.button.button == 1 ) {\n\t\t\t\t\t\tAttractSprite(event.button.x,\n\t\t\t\t\t\t              event.button.y);\n\t\t\t\t\t\tmouse_pressed = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSDL_Rect area;\n\n\t\t\t\t\t\tarea.x = event.button.x-16;\n\t\t\t\t\t\tarea.y = event.button.y-16;\n\t\t\t\t\t\tarea.w = 32;\n\t\t\t\t\t\tarea.h = 32;\n\t\t\t\t\t\tSDL_FillRect(screen, &area, 0);\n\t\t\t\t\t\tSDL_UpdateRects(screen,1,&area);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SDL_KEYDOWN:\n#ifdef _WIN32_WCE\n\t\t\t\t\t// there is no ESC key at all\n\t\t\t\t\tdone = 1;\n#else\n\t\t\t\t\tif ( event.key.keysym.sym == SDLK_ESCAPE ) {\n\t\t\t\t\t\tdone = 1;\n\t\t\t\t\t} else if (event.key.keysym.sym == SDLK_t) {\n\t\t\t\t\t\tvideoflags ^= SDL_FULLSCREEN;\n\t\t\t\t\t\tscreen = SDL_SetVideoMode(w, h, video_bpp, videoflags);\n\t\t\t\t\t\tif ( screen == NULL ) {\n\t\t\t\t\t\t\tfprintf(stderr, \"Couldn't toggle video mode: %s\\n\",\n\t\t\t\t\t\t\t\t\tSDL_GetError());\n\t\t\t\t\t\t\tquit(2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tFillBackground(screen);\n\t\t\t\t\t}\n#endif\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase SDL_QUIT:\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n#ifndef EMSCRIPTEN\n\t}\n\t\n\tSDL_FreeSurface(light);\n\tSDL_FreeSurface(sprite);\n\tSDL_FreeSurface(backing);\n\n\t/* Print out some timing information */\n\tif ( flashes > 0 ) {\n\t\tprintf(\"%d alpha blits, ~%4.4f ms per blit\\n\", \n\t\t\tflashes, (float)flashtime/flashes);\n\t}\n\t\n\tSDL_Quit();\n\treturn(0);\n#else\n\tif(done) {\n\t\tSDL_FreeSurface(light);\n\t\tSDL_FreeSurface(sprite);\n\t\tSDL_FreeSurface(backing);\n\n\t\t/* Print out some timing information */\n\t\tif ( flashes > 0 ) {\n\t\t\tprintf(\"%d alpha blits, ~%4.4f ms per blit\\n\", \n\t\t\t\tflashes, (float)flashtime/flashes);\n\t\t}\n\t\t\n\t\tSDL_Quit();\n\t}\n#endif\n}\n"]}