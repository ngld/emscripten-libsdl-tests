{"version":3,"file":"testshader.c.js","sources":["../SDL-2.0.0/testshader.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2eA;AACA","sourcesContent":["/*\n  Copyright (C) 1997-2013 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely.\n*/\n/* This is a simple example of using GLSL shaders with SDL */\n\n#include <stdio.h> /* for printf() */\n#include \"SDL.h\"\n\n#ifdef HAVE_OPENGL\n\n#include \"SDL_opengl.h\"\n\n\nstatic SDL_bool shaders_supported;\nstatic int      current_shader = 0;\n\nenum {\n    SHADER_COLOR,\n    SHADER_TEXTURE,\n    SHADER_TEXCOORDS,\n    NUM_SHADERS\n};\n\ntypedef struct {\n    GLhandleARB program;\n    GLhandleARB vert_shader;\n    GLhandleARB frag_shader;\n    const char *vert_source;\n    const char *frag_source;\n} ShaderData;\n\nstatic ShaderData shaders[NUM_SHADERS] = {\n\n    /* SHADER_COLOR */\n    { 0, 0, 0,\n        /* vertex shader */\n\"varying vec4 v_color;\\n\"\n\"\\n\"\n\"void main()\\n\"\n\"{\\n\"\n\"    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\\n\"\n\"    v_color = gl_Color;\\n\"\n\"}\",\n        /* fragment shader */\n\"varying vec4 v_color;\\n\"\n\"\\n\"\n\"void main()\\n\"\n\"{\\n\"\n\"    gl_FragColor = v_color;\\n\"\n\"}\"\n    },\n\n    /* SHADER_TEXTURE */\n    { 0, 0, 0,\n        /* vertex shader */\n\"varying vec4 v_color;\\n\"\n\"varying vec2 v_texCoord;\\n\"\n\"\\n\"\n\"void main()\\n\"\n\"{\\n\"\n\"    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\\n\"\n\"    v_color = gl_Color;\\n\"\n\"    v_texCoord = vec2(gl_MultiTexCoord0);\\n\"\n\"}\",\n        /* fragment shader */\n\"varying vec4 v_color;\\n\"\n\"varying vec2 v_texCoord;\\n\"\n\"uniform sampler2D tex0;\\n\"\n\"\\n\"\n\"void main()\\n\"\n\"{\\n\"\n\"    gl_FragColor = texture2D(tex0, v_texCoord) * v_color;\\n\"\n\"}\"\n    },\n\n    /* SHADER_TEXCOORDS */\n    { 0, 0, 0,\n        /* vertex shader */\n\"varying vec2 v_texCoord;\\n\"\n\"\\n\"\n\"void main()\\n\"\n\"{\\n\"\n\"    gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\\n\"\n\"    v_texCoord = vec2(gl_MultiTexCoord0);\\n\"\n\"}\",\n        /* fragment shader */\n\"varying vec2 v_texCoord;\\n\"\n\"\\n\"\n\"void main()\\n\"\n\"{\\n\"\n\"    vec4 color;\\n\"\n\"    vec2 delta;\\n\"\n\"    float dist;\\n\"\n\"\\n\"\n\"    delta = vec2(0.5, 0.5) - v_texCoord;\\n\"\n\"    dist = dot(delta, delta);\\n\"\n\"\\n\"\n\"    color.r = v_texCoord.x;\\n\"\n\"    color.g = v_texCoord.x * v_texCoord.y;\\n\"\n\"    color.b = v_texCoord.y;\\n\"\n\"    color.a = 1.0 - (dist * 4.0);\\n\"\n\"    gl_FragColor = color;\\n\"\n\"}\"\n    },\n};\n\nstatic PFNGLATTACHOBJECTARBPROC glAttachObjectARB;\nstatic PFNGLCOMPILESHADERARBPROC glCompileShaderARB;\nstatic PFNGLCREATEPROGRAMOBJECTARBPROC glCreateProgramObjectARB;\nstatic PFNGLCREATESHADEROBJECTARBPROC glCreateShaderObjectARB;\nstatic PFNGLDELETEOBJECTARBPROC glDeleteObjectARB;\nstatic PFNGLGETINFOLOGARBPROC glGetInfoLogARB;\nstatic PFNGLGETOBJECTPARAMETERIVARBPROC glGetObjectParameterivARB;\nstatic PFNGLGETUNIFORMLOCATIONARBPROC glGetUniformLocationARB;\nstatic PFNGLLINKPROGRAMARBPROC glLinkProgramARB;\nstatic PFNGLSHADERSOURCEARBPROC glShaderSourceARB;\nstatic PFNGLUNIFORM1IARBPROC glUniform1iARB;\nstatic PFNGLUSEPROGRAMOBJECTARBPROC glUseProgramObjectARB;\n\nstatic SDL_bool CompileShader(GLhandleARB shader, const char *source)\n{\n    GLint status;\n\n    glShaderSourceARB(shader, 1, &source, NULL);\n    glCompileShaderARB(shader);\n    glGetObjectParameterivARB(shader, GL_OBJECT_COMPILE_STATUS_ARB, &status);\n    if (status == 0) {\n        GLint length;\n        char *info;\n\n        glGetObjectParameterivARB(shader, GL_OBJECT_INFO_LOG_LENGTH_ARB, &length);\n        info = SDL_stack_alloc(char, length+1);\n        glGetInfoLogARB(shader, length, NULL, info);\n        fprintf(stderr, \"Failed to compile shader:\\n%s\\n%s\", source, info);\n        SDL_stack_free(info);\n\n        return SDL_FALSE;\n    } else {\n        return SDL_TRUE;\n    }\n}\n\nstatic SDL_bool CompileShaderProgram(ShaderData *data)\n{\n    const int num_tmus_bound = 4;\n    int i;\n    GLint location;\n\n    glGetError();\n\n    /* Create one program object to rule them all */\n    data->program = glCreateProgramObjectARB();\n\n    /* Create the vertex shader */\n    data->vert_shader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);\n    if (!CompileShader(data->vert_shader, data->vert_source)) {\n        return SDL_FALSE;\n    }\n\n    /* Create the fragment shader */\n    data->frag_shader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);\n    if (!CompileShader(data->frag_shader, data->frag_source)) {\n        return SDL_FALSE;\n    }\n\n    /* ... and in the darkness bind them */\n    glAttachObjectARB(data->program, data->vert_shader);\n    glAttachObjectARB(data->program, data->frag_shader);\n    glLinkProgramARB(data->program);\n\n    /* Set up some uniform variables */\n    glUseProgramObjectARB(data->program);\n    for (i = 0; i < num_tmus_bound; ++i) {\n        char tex_name[5];\n        SDL_snprintf(tex_name, SDL_arraysize(tex_name), \"tex%d\", i);\n        location = glGetUniformLocationARB(data->program, tex_name);\n        if (location >= 0) {\n            glUniform1iARB(location, i);\n        }\n    }\n    glUseProgramObjectARB(0);\n\n    return (glGetError() == GL_NO_ERROR);\n}\n\nstatic void DestroyShaderProgram(ShaderData *data)\n{\n    if (shaders_supported) {\n        glDeleteObjectARB(data->vert_shader);\n        glDeleteObjectARB(data->frag_shader);\n        glDeleteObjectARB(data->program);\n    }\n}\n\nstatic SDL_bool InitShaders()\n{\n    int i;\n\n    /* Check for shader support */\n    shaders_supported = SDL_FALSE;\n    if (SDL_GL_ExtensionSupported(\"GL_ARB_shader_objects\") &&\n        SDL_GL_ExtensionSupported(\"GL_ARB_shading_language_100\") &&\n        SDL_GL_ExtensionSupported(\"GL_ARB_vertex_shader\") &&\n        SDL_GL_ExtensionSupported(\"GL_ARB_fragment_shader\")) {\n        glAttachObjectARB = (PFNGLATTACHOBJECTARBPROC) SDL_GL_GetProcAddress(\"glAttachObjectARB\");\n        glCompileShaderARB = (PFNGLCOMPILESHADERARBPROC) SDL_GL_GetProcAddress(\"glCompileShaderARB\");\n        glCreateProgramObjectARB = (PFNGLCREATEPROGRAMOBJECTARBPROC) SDL_GL_GetProcAddress(\"glCreateProgramObjectARB\");\n        glCreateShaderObjectARB = (PFNGLCREATESHADEROBJECTARBPROC) SDL_GL_GetProcAddress(\"glCreateShaderObjectARB\");\n        glDeleteObjectARB = (PFNGLDELETEOBJECTARBPROC) SDL_GL_GetProcAddress(\"glDeleteObjectARB\");\n        glGetInfoLogARB = (PFNGLGETINFOLOGARBPROC) SDL_GL_GetProcAddress(\"glGetInfoLogARB\");\n        glGetObjectParameterivARB = (PFNGLGETOBJECTPARAMETERIVARBPROC) SDL_GL_GetProcAddress(\"glGetObjectParameterivARB\");\n        glGetUniformLocationARB = (PFNGLGETUNIFORMLOCATIONARBPROC) SDL_GL_GetProcAddress(\"glGetUniformLocationARB\");\n        glLinkProgramARB = (PFNGLLINKPROGRAMARBPROC) SDL_GL_GetProcAddress(\"glLinkProgramARB\");\n        glShaderSourceARB = (PFNGLSHADERSOURCEARBPROC) SDL_GL_GetProcAddress(\"glShaderSourceARB\");\n        glUniform1iARB = (PFNGLUNIFORM1IARBPROC) SDL_GL_GetProcAddress(\"glUniform1iARB\");\n        glUseProgramObjectARB = (PFNGLUSEPROGRAMOBJECTARBPROC) SDL_GL_GetProcAddress(\"glUseProgramObjectARB\");\n        if (glAttachObjectARB &&\n            glCompileShaderARB &&\n            glCreateProgramObjectARB &&\n            glCreateShaderObjectARB &&\n            glDeleteObjectARB &&\n            glGetInfoLogARB &&\n            glGetObjectParameterivARB &&\n            glGetUniformLocationARB &&\n            glLinkProgramARB &&\n            glShaderSourceARB &&\n            glUniform1iARB &&\n            glUseProgramObjectARB) {\n            shaders_supported = SDL_TRUE;\n        }\n    }\n\n    if (!shaders_supported) {\n        return SDL_FALSE;\n    }\n\n    /* Compile all the shaders */\n    for (i = 0; i < NUM_SHADERS; ++i) {\n        if (!CompileShaderProgram(&shaders[i])) {\n            fprintf(stderr, \"Unable to compile shader!\\n\");\n            return SDL_FALSE;\n        }\n    }\n\n    /* We're done! */\n    return SDL_TRUE;\n}\n\nstatic void QuitShaders()\n{\n    int i;\n\n    for (i = 0; i < NUM_SHADERS; ++i) {\n        DestroyShaderProgram(&shaders[i]);\n    }\n}\n\n/* Quick utility function for texture creation */\nstatic int\npower_of_two(int input)\n{\n    int value = 1;\n\n    while (value < input) {\n        value <<= 1;\n    }\n    return value;\n}\n\nGLuint\nSDL_GL_LoadTexture(SDL_Surface * surface, GLfloat * texcoord)\n{\n    GLuint texture;\n    int w, h;\n    SDL_Surface *image;\n    SDL_Rect area;\n    SDL_BlendMode saved_mode;\n\n    /* Use the surface width and height expanded to powers of 2 */\n    w = power_of_two(surface->w);\n    h = power_of_two(surface->h);\n    texcoord[0] = 0.0f;         /* Min X */\n    texcoord[1] = 0.0f;         /* Min Y */\n    texcoord[2] = (GLfloat) surface->w / w;     /* Max X */\n    texcoord[3] = (GLfloat) surface->h / h;     /* Max Y */\n\n    image = SDL_CreateRGBSurface(SDL_SWSURFACE, w, h, 32,\n#if SDL_BYTEORDER == SDL_LIL_ENDIAN     /* OpenGL RGBA masks */\n                                 0x000000FF,\n                                 0x0000FF00, 0x00FF0000, 0xFF000000\n#else\n                                 0xFF000000,\n                                 0x00FF0000, 0x0000FF00, 0x000000FF\n#endif\n        );\n    if (image == NULL) {\n        return 0;\n    }\n\n    /* Save the alpha blending attributes */\n    SDL_GetSurfaceBlendMode(surface, &saved_mode);\n    SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_NONE);\n\n    /* Copy the surface into the GL texture image */\n    area.x = 0;\n    area.y = 0;\n    area.w = surface->w;\n    area.h = surface->h;\n    SDL_BlitSurface(surface, &area, image, &area);\n\n    /* Restore the alpha blending attributes */\n    SDL_SetSurfaceBlendMode(surface, saved_mode);\n\n    /* Create an OpenGL texture for the image */\n    glGenTextures(1, &texture);\n    glBindTexture(GL_TEXTURE_2D, texture);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexImage2D(GL_TEXTURE_2D,\n                 0,\n                 GL_RGBA, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, image->pixels);\n    SDL_FreeSurface(image);     /* No longer needed */\n\n    return texture;\n}\n\n/* A general OpenGL initialization function.    Sets all of the initial parameters. */\nvoid InitGL(int Width, int Height)                    // We call this right after our OpenGL window is created.\n{\n    GLdouble aspect;\n\n    glViewport(0, 0, Width, Height);\n    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);        // This Will Clear The Background Color To Black\n    glClearDepth(1.0);                // Enables Clearing Of The Depth Buffer\n    glDepthFunc(GL_LESS);                // The Type Of Depth Test To Do\n    glEnable(GL_DEPTH_TEST);            // Enables Depth Testing\n    glShadeModel(GL_SMOOTH);            // Enables Smooth Color Shading\n\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();                // Reset The Projection Matrix\n\n    aspect = (GLdouble)Width / Height;\n    glOrtho(-3.0, 3.0, -3.0 / aspect, 3.0 / aspect, 0.0, 1.0);\n\n    glMatrixMode(GL_MODELVIEW);\n}\n\n/* The main drawing function. */\nvoid DrawGLScene(SDL_Window *window, GLuint texture, GLfloat * texcoord)\n{\n    /* Texture coordinate lookup, to make it simple */\n    enum {\n        MINX,\n        MINY,\n        MAXX,\n        MAXY\n    };\n\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);        // Clear The Screen And The Depth Buffer\n    glLoadIdentity();                // Reset The View\n\n    glTranslatef(-1.5f,0.0f,0.0f);        // Move Left 1.5 Units\n\n    // draw a triangle (in smooth coloring mode)\n    glBegin(GL_POLYGON);                // start drawing a polygon\n    glColor3f(1.0f,0.0f,0.0f);            // Set The Color To Red\n    glVertex3f( 0.0f, 1.0f, 0.0f);        // Top\n    glColor3f(0.0f,1.0f,0.0f);            // Set The Color To Green\n    glVertex3f( 1.0f,-1.0f, 0.0f);        // Bottom Right\n    glColor3f(0.0f,0.0f,1.0f);            // Set The Color To Blue\n    glVertex3f(-1.0f,-1.0f, 0.0f);        // Bottom Left\n    glEnd();                    // we're done with the polygon (smooth color interpolation)\n\n    glTranslatef(3.0f,0.0f,0.0f);         // Move Right 3 Units\n\n    // Enable blending\n    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);\n    glEnable(GL_BLEND);\n    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\n    // draw a textured square (quadrilateral)\n    glEnable(GL_TEXTURE_2D);\n    glBindTexture(GL_TEXTURE_2D, texture);\n    glColor3f(1.0f,1.0f,1.0f);\n    if (shaders_supported) {\n        glUseProgramObjectARB(shaders[current_shader].program);\n    }\n\n    glBegin(GL_QUADS);                // start drawing a polygon (4 sided)\n    glTexCoord2f(texcoord[MINX], texcoord[MINY]);\n    glVertex3f(-1.0f, 1.0f, 0.0f);        // Top Left\n    glTexCoord2f(texcoord[MAXX], texcoord[MINY]);\n    glVertex3f( 1.0f, 1.0f, 0.0f);        // Top Right\n    glTexCoord2f(texcoord[MAXX], texcoord[MAXY]);\n    glVertex3f( 1.0f,-1.0f, 0.0f);        // Bottom Right\n    glTexCoord2f(texcoord[MINX], texcoord[MAXY]);\n    glVertex3f(-1.0f,-1.0f, 0.0f);        // Bottom Left\n    glEnd();                    // done with the polygon\n\n    if (shaders_supported) {\n        glUseProgramObjectARB(0);\n    }\n    glDisable(GL_TEXTURE_2D);\n\n    // swap buffers to display, since we're double buffered.\n    SDL_GL_SwapWindow(window);\n}\n\nint main(int argc, char **argv)\n{\n    int done;\n    SDL_Window *window;\n    SDL_Surface *surface;\n    GLuint texture;\n    GLfloat texcoords[4];\n\n    /* Initialize SDL for video output */\n    if ( SDL_Init(SDL_INIT_VIDEO) < 0 ) {\n        fprintf(stderr, \"Unable to initialize SDL: %s\\n\", SDL_GetError());\n        exit(1);\n    }\n\n    /* Create a 640x480 OpenGL screen */\n    window = SDL_CreateWindow( \"Shader Demo\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 640, 480, SDL_WINDOW_OPENGL );\n    if ( !window ) {\n        fprintf(stderr, \"Unable to create OpenGL window: %s\\n\", SDL_GetError());\n        SDL_Quit();\n        exit(2);\n    }\n\n    if ( !SDL_GL_CreateContext(window)) {\n        fprintf(stderr, \"Unable to create OpenGL context: %s\\n\", SDL_GetError());\n        SDL_Quit();\n        exit(2);\n    }\n\n    surface = SDL_LoadBMP(\"icon.bmp\");\n    if ( ! surface ) {\n        fprintf(stderr, \"Unable to load icon.bmp: %s\\n\", SDL_GetError());\n        SDL_Quit();\n        exit(3);\n    }\n    texture = SDL_GL_LoadTexture(surface, texcoords);\n    SDL_FreeSurface(surface);\n\n    /* Loop, drawing and checking events */\n    InitGL(640, 480);\n    if (InitShaders()) {\n        printf(\"Shaders supported, press SPACE to cycle them.\\n\");\n    } else {\n        printf(\"Shaders not supported!\\n\");\n    }\n    done = 0;\n    while ( ! done ) {\n        DrawGLScene(window, texture, texcoords);\n\n        /* This could go in a separate function */\n        { SDL_Event event;\n            while ( SDL_PollEvent(&event) ) {\n                if ( event.type == SDL_QUIT ) {\n                    done = 1;\n                }\n                if ( event.type == SDL_KEYDOWN ) {\n                    if ( event.key.keysym.sym == SDLK_SPACE ) {\n                        current_shader = (current_shader + 1) % NUM_SHADERS;\n                    }\n                    if ( event.key.keysym.sym == SDLK_ESCAPE ) {\n                        done = 1;\n                    }\n                }\n            }\n        }\n    }\n    QuitShaders();\n    SDL_Quit();\n    return 1;\n}\n\n#else /* HAVE_OPENGL */\n\nint\nmain(int argc, char *argv[])\n{\n    printf(\"No OpenGL support on this system\\n\");\n    return 1;\n}\n\n#endif /* HAVE_OPENGL */\n\n/* vi: set ts=4 sw=4 expandtab: */\n"]}