{"version":3,"file":"testpalette.c.js","sources":["../SDL-1.2.15/testpalette.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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","sourcesContent":["/*\n * testpalette.c\n *\n * A simple test of runtime palette modification for animation\n * (using the SDL_SetPalette() API). \n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n/* This isn't in the Windows headers */\n#ifndef M_PI\n#define M_PI\t3.14159265358979323846\n#endif\n\n#include \"SDL.h\"\n\n/* screen size */\n#define SCRW 640\n#define SCRH 480\n\n#define NBOATS 5\n#define SPEED 2\n\n#ifndef MIN\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#endif\n#ifndef MAX\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#endif\n\n/*\n * wave colours: Made by taking a narrow cross-section of a wave picture\n * in Gimp, saving in PPM ascii format and formatting with Emacs macros.\n */\nstatic SDL_Color wavemap[] = {\n    {0,2,103}, {0,7,110}, {0,13,117}, {0,19,125},\n    {0,25,133}, {0,31,141}, {0,37,150}, {0,43,158},\n    {0,49,166}, {0,55,174}, {0,61,182}, {0,67,190},\n    {0,73,198}, {0,79,206}, {0,86,214}, {0,96,220},\n    {5,105,224}, {12,112,226}, {19,120,227}, {26,128,229},\n    {33,135,230}, {40,143,232}, {47,150,234}, {54,158,236},\n    {61,165,238}, {68,173,239}, {75,180,241}, {82,188,242},\n    {89,195,244}, {96,203,246}, {103,210,248}, {112,218,250},\n    {124,224,250}, {135,226,251}, {146,229,251}, {156,231,252},\n    {167,233,252}, {178,236,252}, {189,238,252}, {200,240,252},\n    {211,242,252}, {222,244,252}, {233,247,252}, {242,249,252},\n    {237,250,252}, {209,251,252}, {174,251,252}, {138,252,252},\n    {102,251,252}, {63,250,252}, {24,243,252}, {7,225,252},\n    {4,203,252}, {3,181,252}, {2,158,252}, {1,136,251},\n    {0,111,248}, {0,82,234}, {0,63,213}, {0,50,192},\n    {0,39,172}, {0,28,152}, {0,17,132}, {0,7,114}\n};\n\n/* Call this instead of exit(), so we can clean up SDL: atexit() is evil. */\nstatic void quit(int rc)\n{\n\tSDL_Quit();\n\texit(rc);\n}\n\nstatic void sdlerr(char *when)\n{\n    fprintf(stderr, \"SDL error: %s: %s\\n\", when, SDL_GetError());\n    quit(1);\n}\n\n/* create a background surface */\nstatic SDL_Surface *make_bg(SDL_Surface *screen, int startcol)\n{\n    int i;\n    SDL_Surface *bg = SDL_CreateRGBSurface(SDL_SWSURFACE, screen->w, screen->h,\n\t\t\t\t\t   8, 0, 0, 0, 0);\n    if(!bg)\n\tsdlerr(\"creating background surface\");\n\n    /* set the palette to the logical screen palette so that blits\n       won't be translated */\n    SDL_SetColors(bg, screen->format->palette->colors, 0, 256);\n\n    /* Make a wavy background pattern using colours 0-63 */\n    if(SDL_LockSurface(bg) < 0)\n\tsdlerr(\"locking background\");\n    for(i = 0; i < SCRH; i++) {\n\tUint8 *p = (Uint8 *)bg->pixels + i * bg->pitch;\n\tint j, d;\n\td = 0;\n\tfor(j = 0; j < SCRW; j++) {\n\t    int v = MAX(d, -2);\n\t    v = MIN(v, 2);\n\t    if(i > 0)\n\t\tv += p[-bg->pitch] + 65 - startcol;\n\t    p[j] = startcol + (v & 63);\n\t    d += ((rand() >> 3) % 3) - 1;\n\t}\n    }\n    SDL_UnlockSurface(bg);\n    return(bg);\n}\n\n/*\n * Return a surface flipped horisontally. Only works for 8bpp;\n * extension to arbitrary bitness is left as an exercise for the reader.\n */\nstatic SDL_Surface *hflip(SDL_Surface *s)\n{\n    int i;\n    SDL_Surface *z = SDL_CreateRGBSurface(SDL_SWSURFACE, s->w, s->h, 8,\n\t\t\t\t\t  0, 0, 0, 0);\n    /* copy palette */\n    SDL_SetColors(z, s->format->palette->colors,\n\t\t  0, s->format->palette->ncolors);\n    if(SDL_LockSurface(s) < 0 || SDL_LockSurface(z) < 0)\n\tsdlerr(\"locking flip images\");\n\n    for(i = 0; i < s->h; i++) {\n\tint j;\n\tUint8 *from = (Uint8 *)s->pixels + i * s->pitch;\n\tUint8 *to = (Uint8 *)z->pixels + i * z->pitch + s->w - 1;\n\tfor(j = 0; j < s->w; j++)\n\t    to[-j] = from[j];\n    }\n\n    SDL_UnlockSurface(z);\n    SDL_UnlockSurface(s);\n    return z;\n}\n\nint main(int argc, char **argv)\n{\n    SDL_Color cmap[256];\n    SDL_Surface *screen;\n    SDL_Surface *bg;\n    SDL_Surface *boat[2];\n    unsigned vidflags = 0;\n    unsigned start;\n    int fade_max = 400;\n    int fade_level, fade_dir;\n    int boatcols, frames, i, red;\n    int boatx[NBOATS], boaty[NBOATS], boatdir[NBOATS];\n    int gamma_fade = 0;\n    int gamma_ramp = 0;\n\n    if(SDL_Init(SDL_INIT_VIDEO) < 0)\n\tsdlerr(\"initialising SDL\");\n\n    while(--argc) {\n\t++argv;\n\tif(strcmp(*argv, \"-hw\") == 0)\n\t    vidflags |= SDL_HWSURFACE;\n\telse if(strcmp(*argv, \"-fullscreen\") == 0)\n\t    vidflags |= SDL_FULLSCREEN;\n\telse if(strcmp(*argv, \"-nofade\") == 0)\n\t    fade_max = 1;\n\telse if(strcmp(*argv, \"-gamma\") == 0)\n\t    gamma_fade = 1;\n\telse if(strcmp(*argv, \"-gammaramp\") == 0)\n\t    gamma_ramp = 1;\n\telse {\n\t    fprintf(stderr,\n\t\t    \"usage: testpalette \"\n\t\t    \" [-hw] [-fullscreen] [-nofade] [-gamma] [-gammaramp]\\n\");\n\t    quit(1);\n\t}\n    }\n\n    /* Ask explicitly for 8bpp and a hardware palette */\n    if((screen = SDL_SetVideoMode(SCRW, SCRH, 8, vidflags | SDL_HWPALETTE)) == NULL) {\n\tfprintf(stderr, \"error setting %dx%d 8bpp indexed mode: %s\\n\",\n\t\tSCRW, SCRH, SDL_GetError());\n\tquit(1);\n    }\n\n    if (vidflags & SDL_FULLSCREEN) SDL_ShowCursor (SDL_FALSE);\n\n    if((boat[0] = SDL_LoadBMP(\"sail.bmp\")) == NULL)\n\tsdlerr(\"loading sail.bmp\");\n    /* We've chosen magenta (#ff00ff) as colour key for the boat */\n    SDL_SetColorKey(boat[0], SDL_SRCCOLORKEY | SDL_RLEACCEL,\n\t\t    SDL_MapRGB(boat[0]->format, 0xff, 0x00, 0xff));\n    boatcols = boat[0]->format->palette->ncolors;\n    boat[1] = hflip(boat[0]);\n    SDL_SetColorKey(boat[1], SDL_SRCCOLORKEY | SDL_RLEACCEL,\n\t\t    SDL_MapRGB(boat[1]->format, 0xff, 0x00, 0xff));\n\n    /*\n     * First set the physical screen palette to black, so the user won't\n     * see our initial drawing on the screen.\n     */\n    memset(cmap, 0, sizeof(cmap));\n    SDL_SetPalette(screen, SDL_PHYSPAL, cmap, 0, 256);\n\n    /*\n     * Proper palette management is important when playing games with the\n     * colormap. We have divided the palette as follows:\n     *\n     * index 0..(boatcols-1):\t\tused for the boat\n     * index boatcols..(boatcols+63):\tused for the waves\n     */\n    SDL_SetPalette(screen, SDL_LOGPAL,\n\t\t   boat[0]->format->palette->colors, 0, boatcols);\n    SDL_SetPalette(screen, SDL_LOGPAL, wavemap, boatcols, 64);\n\n    /*\n     * Now the logical screen palette is set, and will remain unchanged.\n     * The boats already have the same palette so fast blits can be used.\n     */\n    memcpy(cmap, screen->format->palette->colors, 256 * sizeof(SDL_Color));\n\n    /* save the index of the red colour for later */\n    red = SDL_MapRGB(screen->format, 0xff, 0x00, 0x00);\n\n    bg = make_bg(screen, boatcols); /* make a nice wavy background surface */\n\n    /* initial screen contents */\n    if(SDL_BlitSurface(bg, NULL, screen, NULL) < 0)\n\tsdlerr(\"blitting background to screen\");\n    SDL_Flip(screen);\t\t/* actually put the background on screen */\n\n    /* determine initial boat placements */\n    for(i = 0; i < NBOATS; i++) {\n\tboatx[i] = (rand() % (SCRW + boat[0]->w)) - boat[0]->w;\n\tboaty[i] = i * (SCRH - boat[0]->h) / (NBOATS - 1);\n\tboatdir[i] = ((rand() >> 5) & 1) * 2 - 1;\n    }\n\n    start = SDL_GetTicks();\n    frames = 0;\n    fade_dir = 1;\n    fade_level = 0;\n    do {\n\tSDL_Event e;\n\tSDL_Rect updates[NBOATS];\n\tSDL_Rect r;\n\tint redphase;\n\n\t/* A small event loop: just exit on any key or mouse button event */\n\twhile(SDL_PollEvent(&e)) {\n\t    if(e.type == SDL_KEYDOWN || e.type == SDL_QUIT\n\t       || e.type == SDL_MOUSEBUTTONDOWN) {\n\t\tif(fade_dir < 0)\n\t\t    fade_level = 0;\n\t\tfade_dir = -1;\n\t    }\n\t}\n\n\t/* move boats */\n\tfor(i = 0; i < NBOATS; i++) {\n\t    int old_x = boatx[i];\n\t    /* update boat position */\n\t    boatx[i] += boatdir[i] * SPEED;\n\t    if(boatx[i] <= -boat[0]->w || boatx[i] >= SCRW)\n\t\tboatdir[i] = -boatdir[i];\n\n\t    /* paint over the old boat position */\n\t    r.x = old_x;\n\t    r.y = boaty[i];\n\t    r.w = boat[0]->w;\n\t    r.h = boat[0]->h;\n\t    if(SDL_BlitSurface(bg, &r, screen, &r) < 0)\n\t\tsdlerr(\"blitting background\");\n\n\t    /* construct update rectangle (bounding box of old and new pos) */\n\t    updates[i].x = MIN(old_x, boatx[i]);\n\t    updates[i].y = boaty[i];\n\t    updates[i].w = boat[0]->w + SPEED;\n\t    updates[i].h = boat[0]->h;\n\t    /* clip update rectangle to screen */\n\t    if(updates[i].x < 0) {\n\t\tupdates[i].w += updates[i].x;\n\t\tupdates[i].x = 0;\n\t    }\n\t    if(updates[i].x + updates[i].w > SCRW)\n\t\tupdates[i].w = SCRW - updates[i].x;\n\t}\n\n\tfor(i = 0; i < NBOATS; i++) {\n\t    /* paint boat on new position */\n\t    r.x = boatx[i];\n\t    r.y = boaty[i];\n\t    if(SDL_BlitSurface(boat[(boatdir[i] + 1) / 2], NULL,\n\t\t\t       screen, &r) < 0)\n\t\tsdlerr(\"blitting boat\");\n\t}\n\n\t/* cycle wave palette */\n\tfor(i = 0; i < 64; i++)\n\t    cmap[boatcols + ((i + frames) & 63)] = wavemap[i];\n\n\tif(fade_dir) {\n\t    /* Fade the entire palette in/out */\n\t    fade_level += fade_dir;\n\n\t    if(gamma_fade) {\n\t\t/* Fade linearly in gamma level (lousy) */\n\t\tfloat level = (float)fade_level / fade_max;\n\t\tif(SDL_SetGamma(level, level, level) < 0)\n\t\t    sdlerr(\"setting gamma\");\n\n\t    } else if(gamma_ramp) {\n\t\t/* Fade using gamma ramp (better) */\n\t\tUint16 ramp[256];\n\t\tfor(i = 0; i < 256; i++)\n\t\t    ramp[i] = (i * fade_level / fade_max) << 8;\n\t\tif(SDL_SetGammaRamp(ramp, ramp, ramp) < 0)\n\t\t    sdlerr(\"setting gamma ramp\");\n\n\t    } else {\n\t\t/* Fade using direct palette manipulation (best) */\n\t\tmemcpy(cmap, screen->format->palette->colors,\n\t\t       boatcols * sizeof(SDL_Color));\n\t\tfor(i = 0; i < boatcols + 64; i++) {\n\t\t    cmap[i].r = cmap[i].r * fade_level / fade_max;\n\t\t    cmap[i].g = cmap[i].g * fade_level / fade_max;\n\t\t    cmap[i].b = cmap[i].b * fade_level / fade_max;\n\t\t}\n\t    }\n\t    if(fade_level == fade_max)\n\t\tfade_dir = 0;\n\t}\n\n\t/* pulse the red colour (done after the fade, for a night effect) */\n\tredphase = frames % 64;\n\tcmap[red].r = (int)(255 * sin(redphase * M_PI / 63));\n\n\tSDL_SetPalette(screen, SDL_PHYSPAL, cmap, 0, boatcols + 64);\n\n\t/* update changed areas of the screen */\n\tSDL_UpdateRects(screen, NBOATS, updates);\n\tframes++;\n    } while(fade_level > 0);\n\n    printf(\"%d frames, %.2f fps\\n\",\n\t   frames, 1000.0 * frames / (SDL_GetTicks() - start));\n\n    if (vidflags & SDL_FULLSCREEN) SDL_ShowCursor (SDL_TRUE);\n    SDL_Quit();\n    return 0;\n}\n\n"]}