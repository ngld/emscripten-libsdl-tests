{"version":3,"file":"testgl.c.js","sources":["../SDL-1.2.15/testgl.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAm1BA;AACA","sourcesContent":["#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#include \"SDL.h\"\n\n#ifdef __MACOS__\n#define HAVE_OPENGL\n#endif\n\n#ifdef HAVE_OPENGL\n\n#include \"SDL_opengl.h\"\n\n/* Undefine this if you want a flat cube instead of a rainbow cube */\n#define SHADED_CUBE\n\n/* Define this to be the name of the logo image to use with -logo */\n#define LOGO_FILE\t\"icon.bmp\"\n\n/* The SDL_OPENGLBLIT interface is deprecated.\n   The code is still available for benchmark purposes though.\n*/\n\nstatic SDL_bool USE_DEPRECATED_OPENGLBLIT = SDL_FALSE;\n\nstatic SDL_Surface *global_image = NULL;\nstatic GLuint global_texture = 0;\nstatic GLuint cursor_texture = 0;\n\n/**********************************************************************/\n\nvoid HotKey_ToggleFullScreen(void)\n{\n\tSDL_Surface *screen;\n\n\tscreen = SDL_GetVideoSurface();\n\tif ( SDL_WM_ToggleFullScreen(screen) ) {\n\t\tprintf(\"Toggled fullscreen mode - now %s\\n\",\n\t\t    (screen->flags&SDL_FULLSCREEN) ? \"fullscreen\" : \"windowed\");\n\t} else {\n\t\tprintf(\"Unable to toggle fullscreen mode\\n\");\n\t}\n}\n\nvoid HotKey_ToggleGrab(void)\n{\n\tSDL_GrabMode mode;\n\n\tprintf(\"Ctrl-G: toggling input grab!\\n\");\n\tmode = SDL_WM_GrabInput(SDL_GRAB_QUERY);\n\tif ( mode == SDL_GRAB_ON ) {\n\t\tprintf(\"Grab was on\\n\");\n\t} else {\n\t\tprintf(\"Grab was off\\n\");\n\t}\n\tmode = SDL_WM_GrabInput(!mode);\n\tif ( mode == SDL_GRAB_ON ) {\n\t\tprintf(\"Grab is now on\\n\");\n\t} else {\n\t\tprintf(\"Grab is now off\\n\");\n\t}\n}\n\nvoid HotKey_Iconify(void)\n{\n\tprintf(\"Ctrl-Z: iconifying window!\\n\");\n\tSDL_WM_IconifyWindow();\n}\n\nint HandleEvent(SDL_Event *event)\n{\n\tint done;\n\n\tdone = 0;\n\tswitch( event->type ) {\n\t    case SDL_ACTIVEEVENT:\n\t\t/* See what happened */\n\t\tprintf( \"app %s \", event->active.gain ? \"gained\" : \"lost\" );\n\t\tif ( event->active.state & SDL_APPACTIVE ) {\n\t\t\tprintf( \"active \" );\n\t\t} else if ( event->active.state & SDL_APPMOUSEFOCUS ) {\n\t\t\tprintf( \"mouse \" );\n\t\t} else if ( event->active.state & SDL_APPINPUTFOCUS ) {\n\t\t\tprintf( \"input \" );\n\t\t}\n\t\tprintf( \"focus\\n\" );\n\t\tbreak;\n\t\t\n\n\t    case SDL_KEYDOWN:\n\t\tif ( event->key.keysym.sym == SDLK_ESCAPE ) {\n\t\t\tdone = 1;\n\t\t}\n\t\tif ( (event->key.keysym.sym == SDLK_g) &&\n\t\t     (event->key.keysym.mod & KMOD_CTRL) ) {\n\t\t\tHotKey_ToggleGrab();\n\t\t}\n\t\tif ( (event->key.keysym.sym == SDLK_z) &&\n\t\t     (event->key.keysym.mod & KMOD_CTRL) ) {\n\t\t\tHotKey_Iconify();\n\t\t}\n\t\tif ( (event->key.keysym.sym == SDLK_RETURN) &&\n\t\t     (event->key.keysym.mod & KMOD_ALT) ) {\n\t\t\tHotKey_ToggleFullScreen();\n\t\t}\n\t\tprintf(\"key '%s' pressed\\n\", \n\t\t\tSDL_GetKeyName(event->key.keysym.sym));\n\t\tbreak;\n\t    case SDL_QUIT:\n\t\tdone = 1;\n\t\tbreak;\n\t}\n\treturn(done);\n}\n\nvoid SDL_GL_Enter2DMode()\n{\n\tSDL_Surface *screen = SDL_GetVideoSurface();\n\n\t/* Note, there may be other things you need to change,\n\t   depending on how you have your OpenGL state set up.\n\t*/\n\tglPushAttrib(GL_ENABLE_BIT);\n\tglDisable(GL_DEPTH_TEST);\n\tglDisable(GL_CULL_FACE);\n\tglEnable(GL_TEXTURE_2D);\n\n\t/* This allows alpha blending of 2D textures with the scene */\n\tglEnable(GL_BLEND);\n\tglBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);\n\n\tglViewport(0, 0, screen->w, screen->h);\n\n\tglMatrixMode(GL_PROJECTION);\n\tglPushMatrix();\n\tglLoadIdentity();\n\n\tglOrtho(0.0, (GLdouble)screen->w, (GLdouble)screen->h, 0.0, 0.0, 1.0);\n\n\tglMatrixMode(GL_MODELVIEW);\n\tglPushMatrix();\n\tglLoadIdentity();\n\n\tglTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);\n}\n\nvoid SDL_GL_Leave2DMode()\n{\n\tglMatrixMode(GL_MODELVIEW);\n\tglPopMatrix();\n\n\tglMatrixMode(GL_PROJECTION);\n\tglPopMatrix();\n\n\tglPopAttrib();\n}\n\n/* Quick utility function for texture creation */\nstatic int power_of_two(int input)\n{\n\tint value = 1;\n\n\twhile ( value < input ) {\n\t\tvalue <<= 1;\n\t}\n\treturn value;\n}\n\nGLuint SDL_GL_LoadTexture(SDL_Surface *surface, GLfloat *texcoord)\n{\n\tGLuint texture;\n\tint w, h;\n\tSDL_Surface *image;\n\tSDL_Rect area;\n\tUint32 saved_flags;\n\tUint8  saved_alpha;\n\n\t/* Use the surface width and height expanded to powers of 2 */\n\tw = power_of_two(surface->w);\n\th = power_of_two(surface->h);\n\ttexcoord[0] = 0.0f;\t\t\t/* Min X */\n\ttexcoord[1] = 0.0f;\t\t\t/* Min Y */\n\ttexcoord[2] = (GLfloat)surface->w / w;\t/* Max X */\n\ttexcoord[3] = (GLfloat)surface->h / h;\t/* Max Y */\n\n\timage = SDL_CreateRGBSurface(\n\t\t\tSDL_SWSURFACE,\n\t\t\tw, h,\n\t\t\t32,\n#if SDL_BYTEORDER == SDL_LIL_ENDIAN /* OpenGL RGBA masks */\n\t\t\t0x000000FF, \n\t\t\t0x0000FF00, \n\t\t\t0x00FF0000, \n\t\t\t0xFF000000\n#else\n\t\t\t0xFF000000,\n\t\t\t0x00FF0000, \n\t\t\t0x0000FF00, \n\t\t\t0x000000FF\n#endif\n\t\t       );\n\tif ( image == NULL ) {\n\t\treturn 0;\n\t}\n\n\t/* Save the alpha blending attributes */\n\tsaved_flags = surface->flags&(SDL_SRCALPHA|SDL_RLEACCELOK);\n\tsaved_alpha = surface->format->alpha;\n\tif ( (saved_flags & SDL_SRCALPHA) == SDL_SRCALPHA ) {\n\t\tSDL_SetAlpha(surface, 0, 0);\n\t}\n\n\t/* Copy the surface into the GL texture image */\n\tarea.x = 0;\n\tarea.y = 0;\n\tarea.w = surface->w;\n\tarea.h = surface->h;\n\tSDL_BlitSurface(surface, &area, image, &area);\n\n\t/* Restore the alpha blending attributes */\n\tif ( (saved_flags & SDL_SRCALPHA) == SDL_SRCALPHA ) {\n\t\tSDL_SetAlpha(surface, saved_flags, saved_alpha);\n\t}\n\n\t/* Create an OpenGL texture for the image */\n\tglGenTextures(1, &texture);\n\tglBindTexture(GL_TEXTURE_2D, texture);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\tglTexImage2D(GL_TEXTURE_2D,\n\t\t     0,\n\t\t     GL_RGBA,\n\t\t     w, h,\n\t\t     0,\n\t\t     GL_RGBA,\n\t\t     GL_UNSIGNED_BYTE,\n\t\t     image->pixels);\n\tSDL_FreeSurface(image); /* No longer needed */\n\n\treturn texture;\n}\n\nvoid DrawLogoCursor(void)\n{\n\tstatic GLfloat texMinX, texMinY;\n\tstatic GLfloat texMaxX, texMaxY;\n\tstatic int w, h;\n\tint x, y;\n\n\tif ( ! cursor_texture ) {\n\t\tSDL_Surface *image;\n\t\tGLfloat texcoord[4];\n\n\t\t/* Load the image (could use SDL_image library here) */\n\t\timage = SDL_LoadBMP(LOGO_FILE);\n\t\tif ( image == NULL ) {\n\t\t\treturn;\n\t\t}\n\t\tw = image->w;\n\t\th = image->h;\n\n\t\t/* Convert the image into an OpenGL texture */\n\t\tcursor_texture = SDL_GL_LoadTexture(image, texcoord);\n\n\t\t/* Make texture coordinates easy to understand */\n\t\ttexMinX = texcoord[0];\n\t\ttexMinY = texcoord[1];\n\t\ttexMaxX = texcoord[2];\n\t\ttexMaxY = texcoord[3];\n\n\t\t/* We don't need the original image anymore */\n\t\tSDL_FreeSurface(image);\n\n\t\t/* Make sure that the texture conversion is okay */\n\t\tif ( ! cursor_texture ) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Move the image around */\n\tSDL_GetMouseState(&x, &y);\n\tx -= w/2;\n\ty -= h/2;\n\n\t/* Show the image on the screen */\n\tSDL_GL_Enter2DMode();\n\tglBindTexture(GL_TEXTURE_2D, cursor_texture);\n\tglBegin(GL_TRIANGLE_STRIP);\n\tglTexCoord2f(texMinX, texMinY); glVertex2i(x,   y  );\n\tglTexCoord2f(texMaxX, texMinY); glVertex2i(x+w, y  );\n\tglTexCoord2f(texMinX, texMaxY); glVertex2i(x,   y+h);\n\tglTexCoord2f(texMaxX, texMaxY); glVertex2i(x+w, y+h);\n\tglEnd();\n\tSDL_GL_Leave2DMode();\n}\n\nvoid DrawLogoTexture(void)\n{\n\tstatic GLfloat texMinX, texMinY;\n\tstatic GLfloat texMaxX, texMaxY;\n\tstatic int x = 0;\n\tstatic int y = 0;\n\tstatic int w, h;\n\tstatic int delta_x = 1;\n\tstatic int delta_y = 1;\n\n\tSDL_Surface *screen = SDL_GetVideoSurface();\n\n\tif ( ! global_texture ) {\n\t\tSDL_Surface *image;\n\t\tGLfloat texcoord[4];\n\n\t\t/* Load the image (could use SDL_image library here) */\n\t\timage = SDL_LoadBMP(LOGO_FILE);\n\t\tif ( image == NULL ) {\n\t\t\treturn;\n\t\t}\n\t\tw = image->w;\n\t\th = image->h;\n\n\t\t/* Convert the image into an OpenGL texture */\n\t\tglobal_texture = SDL_GL_LoadTexture(image, texcoord);\n\n\t\t/* Make texture coordinates easy to understand */\n\t\ttexMinX = texcoord[0];\n\t\ttexMinY = texcoord[1];\n\t\ttexMaxX = texcoord[2];\n\t\ttexMaxY = texcoord[3];\n\n\t\t/* We don't need the original image anymore */\n\t\tSDL_FreeSurface(image);\n\n\t\t/* Make sure that the texture conversion is okay */\n\t\tif ( ! global_texture ) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Move the image around */\n\tx += delta_x;\n\tif ( x < 0 ) {\n\t\tx = 0;\n\t\tdelta_x = -delta_x;\n\t} else\n\tif ( (x+w) > screen->w ) {\n\t\tx = screen->w-w;\n\t\tdelta_x = -delta_x;\n\t}\n\ty += delta_y;\n\tif ( y < 0 ) {\n\t\ty = 0;\n\t\tdelta_y = -delta_y;\n\t} else\n\tif ( (y+h) > screen->h ) {\n\t\ty = screen->h-h;\n\t\tdelta_y = -delta_y;\n\t}\n\n\t/* Show the image on the screen */\n\tSDL_GL_Enter2DMode();\n\tglBindTexture(GL_TEXTURE_2D, global_texture);\n\tglBegin(GL_TRIANGLE_STRIP);\n\tglTexCoord2f(texMinX, texMinY); glVertex2i(x,   y  );\n\tglTexCoord2f(texMaxX, texMinY); glVertex2i(x+w, y  );\n\tglTexCoord2f(texMinX, texMaxY); glVertex2i(x,   y+h);\n\tglTexCoord2f(texMaxX, texMaxY); glVertex2i(x+w, y+h);\n\tglEnd();\n\tSDL_GL_Leave2DMode();\n}\n\n/* This code is deprecated, but available for speed comparisons */\nvoid DrawLogoBlit(void)\n{\n\tstatic int x = 0;\n\tstatic int y = 0;\n\tstatic int w, h;\n\tstatic int delta_x = 1;\n\tstatic int delta_y = 1;\n\n\tSDL_Rect dst;\n\tSDL_Surface *screen = SDL_GetVideoSurface();\n\n\tif ( global_image == NULL ) {\n\t\tSDL_Surface *temp;\n\n\t\t/* Load the image (could use SDL_image library here) */\n\t\ttemp = SDL_LoadBMP(LOGO_FILE);\n\t\tif ( temp == NULL ) {\n\t\t\treturn;\n\t\t}\n\t\tw = temp->w;\n\t\th = temp->h;\n\n\t\t/* Convert the image into the screen format */\n\t\tglobal_image = SDL_CreateRGBSurface(\n\t\t\t\tSDL_SWSURFACE,\n\t\t\t\tw, h,\n\t\t\t\tscreen->format->BitsPerPixel,\n\t\t\t\tscreen->format->Rmask,\n\t\t\t\tscreen->format->Gmask,\n\t\t\t\tscreen->format->Bmask,\n\t\t\t\tscreen->format->Amask);\n\t\tif ( global_image ) {\n\t\t\tSDL_BlitSurface(temp, NULL, global_image, NULL);\n\t\t}\n\t\tSDL_FreeSurface(temp);\n\n\t\t/* Make sure that the texture conversion is okay */\n\t\tif ( ! global_image ) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* Move the image around\n           Note that we do not clear the old position.  This is because we\n           perform a glClear() which clears the framebuffer and then only\n           update the new area.\n           Note that you can also achieve interesting effects by modifying\n           the screen surface alpha channel.  It's set to 255 by default..\n         */\n\tx += delta_x;\n\tif ( x < 0 ) {\n\t\tx = 0;\n\t\tdelta_x = -delta_x;\n\t} else\n\tif ( (x+w) > screen->w ) {\n\t\tx = screen->w-w;\n\t\tdelta_x = -delta_x;\n\t}\n\ty += delta_y;\n\tif ( y < 0 ) {\n\t\ty = 0;\n\t\tdelta_y = -delta_y;\n\t} else\n\tif ( (y+h) > screen->h ) {\n\t\ty = screen->h-h;\n\t\tdelta_y = -delta_y;\n\t}\n\tdst.x = x;\n\tdst.y = y;\n\tdst.w = w;\n\tdst.h = h;\n\tSDL_BlitSurface(global_image, NULL, screen, &dst);\n\n\t/* Show the image on the screen */\n\tSDL_UpdateRects(screen, 1, &dst);\n}\n\nint RunGLTest( int argc, char* argv[],\n               int logo, int logocursor, int slowly, int bpp, float gamma, int noframe, int fsaa, int sync, int accel )\n{\n\tint i;\n\tint rgb_size[3];\n\tint w = 640;\n\tint h = 480;\n\tint done = 0;\n\tint frames;\n\tUint32 start_time, this_time;\n        float color[8][3]= {{ 1.0,  1.0,  0.0}, \n\t\t\t    { 1.0,  0.0,  0.0},\n\t\t\t    { 0.0,  0.0,  0.0},\n\t\t\t    { 0.0,  1.0,  0.0},\n\t\t\t    { 0.0,  1.0,  1.0},\n\t\t\t    { 1.0,  1.0,  1.0},\n\t\t\t    { 1.0,  0.0,  1.0},\n\t\t\t    { 0.0,  0.0,  1.0}};\n\tfloat cube[8][3]= {{ 0.5,  0.5, -0.5}, \n\t\t\t   { 0.5, -0.5, -0.5},\n\t\t\t   {-0.5, -0.5, -0.5},\n\t\t\t   {-0.5,  0.5, -0.5},\n\t\t\t   {-0.5,  0.5,  0.5},\n\t\t\t   { 0.5,  0.5,  0.5},\n\t\t\t   { 0.5, -0.5,  0.5},\n\t\t\t   {-0.5, -0.5,  0.5}};\n\tUint32 video_flags;\n\tint value;\n\n\tif( SDL_Init( SDL_INIT_VIDEO ) < 0 ) {\n\t\tfprintf(stderr,\"Couldn't initialize SDL: %s\\n\",SDL_GetError());\n\t\texit( 1 );\n\t}\n\n\t/* See if we should detect the display depth */\n\tif ( bpp == 0 ) {\n\t\tif ( SDL_GetVideoInfo()->vfmt->BitsPerPixel <= 8 ) {\n\t\t\tbpp = 8;\n\t\t} else {\n\t\t\tbpp = 16;  /* More doesn't seem to work */\n\t\t}\n\t}\n\n\t/* Set the flags we want to use for setting the video mode */\n\tif ( logo && USE_DEPRECATED_OPENGLBLIT ) {\n\t\tvideo_flags = SDL_OPENGLBLIT;\n\t} else {\n\t\tvideo_flags = SDL_OPENGL;\n\t}\n\tfor ( i=1; argv[i]; ++i ) {\n\t\tif ( strcmp(argv[i], \"-fullscreen\") == 0 ) {\n\t\t\tvideo_flags |= SDL_FULLSCREEN;\n\t\t}\n\t}\n\n        if (noframe) {\n           video_flags |= SDL_NOFRAME;\n        }\n\n\t/* Initialize the display */\n\tswitch (bpp) {\n\t    case 8:\n\t\trgb_size[0] = 3;\n\t\trgb_size[1] = 3;\n\t\trgb_size[2] = 2;\n\t\tbreak;\n\t    case 15:\n\t    case 16:\n\t\trgb_size[0] = 5;\n\t\trgb_size[1] = 5;\n\t\trgb_size[2] = 5;\n\t\tbreak;\n            default:\n\t\trgb_size[0] = 8;\n\t\trgb_size[1] = 8;\n\t\trgb_size[2] = 8;\n\t\tbreak;\n\t}\n\tSDL_GL_SetAttribute( SDL_GL_RED_SIZE, rgb_size[0] );\n\tSDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, rgb_size[1] );\n\tSDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, rgb_size[2] );\n\tSDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 );\n\tSDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );\n\tif ( fsaa ) {\n\t\tSDL_GL_SetAttribute( SDL_GL_MULTISAMPLEBUFFERS, 1 );\n\t\tSDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, fsaa );\n\t}\n\tif ( accel ) {\n\t\tSDL_GL_SetAttribute( SDL_GL_ACCELERATED_VISUAL, 1 );\n\t}\n\tif ( sync ) {\n\t\tSDL_GL_SetAttribute( SDL_GL_SWAP_CONTROL, 1 );\n\t} else {\n\t\tSDL_GL_SetAttribute( SDL_GL_SWAP_CONTROL, 0 );\n\t}\n\tif ( SDL_SetVideoMode( w, h, bpp, video_flags ) == NULL ) {\n\t\tfprintf(stderr, \"Couldn't set GL mode: %s\\n\", SDL_GetError());\n\t\tSDL_Quit();\n\t\texit(1);\n\t}\n\n\tprintf(\"Screen BPP: %d\\n\", SDL_GetVideoSurface()->format->BitsPerPixel);\n\tprintf(\"\\n\");\n\tprintf( \"Vendor     : %s\\n\", glGetString( GL_VENDOR ) );\n\tprintf( \"Renderer   : %s\\n\", glGetString( GL_RENDERER ) );\n\tprintf( \"Version    : %s\\n\", glGetString( GL_VERSION ) );\n\tprintf( \"Extensions : %s\\n\", glGetString( GL_EXTENSIONS ) );\n\tprintf(\"\\n\");\n\n\tSDL_GL_GetAttribute( SDL_GL_RED_SIZE, &value );\n\tprintf( \"SDL_GL_RED_SIZE: requested %d, got %d\\n\", rgb_size[0],value);\n\tSDL_GL_GetAttribute( SDL_GL_GREEN_SIZE, &value );\n\tprintf( \"SDL_GL_GREEN_SIZE: requested %d, got %d\\n\", rgb_size[1],value);\n\tSDL_GL_GetAttribute( SDL_GL_BLUE_SIZE, &value );\n\tprintf( \"SDL_GL_BLUE_SIZE: requested %d, got %d\\n\", rgb_size[2],value);\n\tSDL_GL_GetAttribute( SDL_GL_DEPTH_SIZE, &value );\n\tprintf( \"SDL_GL_DEPTH_SIZE: requested %d, got %d\\n\", bpp, value );\n\tSDL_GL_GetAttribute( SDL_GL_DOUBLEBUFFER, &value );\n\tprintf( \"SDL_GL_DOUBLEBUFFER: requested 1, got %d\\n\", value );\n\tif ( fsaa ) {\n\t\tSDL_GL_GetAttribute( SDL_GL_MULTISAMPLEBUFFERS, &value );\n\t\tprintf(\"SDL_GL_MULTISAMPLEBUFFERS: requested 1, got %d\\n\", value );\n\t\tSDL_GL_GetAttribute( SDL_GL_MULTISAMPLESAMPLES, &value );\n\t\tprintf(\"SDL_GL_MULTISAMPLESAMPLES: requested %d, got %d\\n\", fsaa, value );\n\t}\n\tif ( accel ) {\n\t\tSDL_GL_GetAttribute( SDL_GL_ACCELERATED_VISUAL, &value );\n\t\tprintf( \"SDL_GL_ACCELERATED_VISUAL: requested 1, got %d\\n\", value );\n\t}\n\tif ( sync ) {\n\t\tSDL_GL_GetAttribute( SDL_GL_SWAP_CONTROL, &value );\n\t\tprintf( \"SDL_GL_SWAP_CONTROL: requested 1, got %d\\n\", value );\n\t}\n\n\t/* Set the window manager title bar */\n\tSDL_WM_SetCaption( \"SDL GL test\", \"testgl\" );\n\n\t/* Set the gamma for the window */\n\tif ( gamma != 0.0 ) {\n\t\tSDL_SetGamma(gamma, gamma, gamma);\n\t}\n\n\tglViewport( 0, 0, w, h );\n\tglMatrixMode( GL_PROJECTION );\n\tglLoadIdentity( );\n\n\tglOrtho( -2.0, 2.0, -2.0, 2.0, -20.0, 20.0 );\n\n\tglMatrixMode( GL_MODELVIEW );\n\tglLoadIdentity( );\n\n\tglEnable(GL_DEPTH_TEST);\n\n\tglDepthFunc(GL_LESS);\n\n\tglShadeModel(GL_SMOOTH);\n\n\t/* Loop until done. */\n\tstart_time = SDL_GetTicks();\n\tframes = 0;\n\twhile( !done ) {\n\t\tGLenum gl_error;\n\t\tchar* sdl_error;\n\t\tSDL_Event event;\n\n\t\t/* Do our drawing, too. */\n\t\tglClearColor( 0.0, 0.0, 0.0, 1.0 );\n\t\tglClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\t\tglBegin( GL_QUADS );\n\n#ifdef SHADED_CUBE\n\t\t\tglColor3fv(color[0]);\n\t\t\tglVertex3fv(cube[0]);\n\t\t\tglColor3fv(color[1]);\n\t\t\tglVertex3fv(cube[1]);\n\t\t\tglColor3fv(color[2]);\n\t\t\tglVertex3fv(cube[2]);\n\t\t\tglColor3fv(color[3]);\n\t\t\tglVertex3fv(cube[3]);\n\t\t\t\n\t\t\tglColor3fv(color[3]);\n\t\t\tglVertex3fv(cube[3]);\n\t\t\tglColor3fv(color[4]);\n\t\t\tglVertex3fv(cube[4]);\n\t\t\tglColor3fv(color[7]);\n\t\t\tglVertex3fv(cube[7]);\n\t\t\tglColor3fv(color[2]);\n\t\t\tglVertex3fv(cube[2]);\n\t\t\t\n\t\t\tglColor3fv(color[0]);\n\t\t\tglVertex3fv(cube[0]);\n\t\t\tglColor3fv(color[5]);\n\t\t\tglVertex3fv(cube[5]);\n\t\t\tglColor3fv(color[6]);\n\t\t\tglVertex3fv(cube[6]);\n\t\t\tglColor3fv(color[1]);\n\t\t\tglVertex3fv(cube[1]);\n\t\t\t\n\t\t\tglColor3fv(color[5]);\n\t\t\tglVertex3fv(cube[5]);\n\t\t\tglColor3fv(color[4]);\n\t\t\tglVertex3fv(cube[4]);\n\t\t\tglColor3fv(color[7]);\n\t\t\tglVertex3fv(cube[7]);\n\t\t\tglColor3fv(color[6]);\n\t\t\tglVertex3fv(cube[6]);\n\n\t\t\tglColor3fv(color[5]);\n\t\t\tglVertex3fv(cube[5]);\n\t\t\tglColor3fv(color[0]);\n\t\t\tglVertex3fv(cube[0]);\n\t\t\tglColor3fv(color[3]);\n\t\t\tglVertex3fv(cube[3]);\n\t\t\tglColor3fv(color[4]);\n\t\t\tglVertex3fv(cube[4]);\n\n\t\t\tglColor3fv(color[6]);\n\t\t\tglVertex3fv(cube[6]);\n\t\t\tglColor3fv(color[1]);\n\t\t\tglVertex3fv(cube[1]);\n\t\t\tglColor3fv(color[2]);\n\t\t\tglVertex3fv(cube[2]);\n\t\t\tglColor3fv(color[7]);\n\t\t\tglVertex3fv(cube[7]);\n#else /* flat cube */\n\t\t\tglColor3f(1.0, 0.0, 0.0);\n\t\t\tglVertex3fv(cube[0]);\n\t\t\tglVertex3fv(cube[1]);\n\t\t\tglVertex3fv(cube[2]);\n\t\t\tglVertex3fv(cube[3]);\n\t\t\t\n\t\t\tglColor3f(0.0, 1.0, 0.0);\n\t\t\tglVertex3fv(cube[3]);\n\t\t\tglVertex3fv(cube[4]);\n\t\t\tglVertex3fv(cube[7]);\n\t\t\tglVertex3fv(cube[2]);\n\t\t\t\n\t\t\tglColor3f(0.0, 0.0, 1.0);\n\t\t\tglVertex3fv(cube[0]);\n\t\t\tglVertex3fv(cube[5]);\n\t\t\tglVertex3fv(cube[6]);\n\t\t\tglVertex3fv(cube[1]);\n\t\t\t\n\t\t\tglColor3f(0.0, 1.0, 1.0);\n\t\t\tglVertex3fv(cube[5]);\n\t\t\tglVertex3fv(cube[4]);\n\t\t\tglVertex3fv(cube[7]);\n\t\t\tglVertex3fv(cube[6]);\n\n\t\t\tglColor3f(1.0, 1.0, 0.0);\n\t\t\tglVertex3fv(cube[5]);\n\t\t\tglVertex3fv(cube[0]);\n\t\t\tglVertex3fv(cube[3]);\n\t\t\tglVertex3fv(cube[4]);\n\n\t\t\tglColor3f(1.0, 0.0, 1.0);\n\t\t\tglVertex3fv(cube[6]);\n\t\t\tglVertex3fv(cube[1]);\n\t\t\tglVertex3fv(cube[2]);\n\t\t\tglVertex3fv(cube[7]);\n#endif /* SHADED_CUBE */\n\n\t\tglEnd( );\n\t\t\n\t\tglMatrixMode(GL_MODELVIEW);\n\t\tglRotatef(5.0, 1.0, 1.0, 1.0);\n\n\t\t/* Draw 2D logo onto the 3D display */\n\t\tif ( logo ) {\n\t\t\tif ( USE_DEPRECATED_OPENGLBLIT ) {\n\t\t\t\tDrawLogoBlit();\n\t\t\t} else {\n\t\t\t\tDrawLogoTexture();\n\t\t\t}\n\t\t}\n\t\tif ( logocursor ) {\n\t\t\tDrawLogoCursor();\n\t\t}\n\n\t\tSDL_GL_SwapBuffers( );\n\n\t\t/* Check for error conditions. */\n\t\tgl_error = glGetError( );\n\n\t\tif( gl_error != GL_NO_ERROR ) {\n\t\t\tfprintf( stderr, \"testgl: OpenGL error: %d\\n\", gl_error );\n\t\t}\n\n\t\tsdl_error = SDL_GetError( );\n\n\t\tif( sdl_error[0] != '\\0' ) {\n\t\t\tfprintf(stderr, \"testgl: SDL error '%s'\\n\", sdl_error);\n\t\t\tSDL_ClearError();\n\t\t}\n\n\t\t/* Allow the user to see what's happening */\n\t\tif ( slowly ) {\n\t\t\tSDL_Delay( 20 );\n\t\t}\n\n\t\t/* Check if there's a pending event. */\n\t\twhile( SDL_PollEvent( &event ) ) {\n\t\t\tdone = HandleEvent(&event);\n\t\t}\n\t\t++frames;\n\t}\n\n\t/* Print out the frames per second */\n\tthis_time = SDL_GetTicks();\n\tif ( this_time != start_time ) {\n\t\tprintf(\"%2.2f FPS\\n\",\n\t\t\t((float)frames/(this_time-start_time))*1000.0);\n\t}\n\n\tif ( global_image ) {\n\t   \tSDL_FreeSurface(global_image);\n\t\tglobal_image = NULL;\n\t}\n\tif ( global_texture ) {\n\t\tglDeleteTextures( 1, &global_texture );\n\t\tglobal_texture = 0;\n\t}\n\tif ( cursor_texture ) {\n\t\tglDeleteTextures( 1, &cursor_texture );\n\t\tcursor_texture = 0;\n\t}\n\n\t/* Destroy our GL context, etc. */\n\tSDL_Quit( );\n\treturn(0);\n}\n\nint main(int argc, char *argv[])\n{\n\tint i, logo, logocursor = 0;\n\tint numtests;\n\tint bpp = 0;\n\tint slowly;\n\tfloat gamma = 0.0;\n\tint noframe = 0;\n\tint fsaa = 0;\n\tint accel = 0;\n\tint sync = 0;\n\n\tlogo = 0;\n\tslowly = 0;\n\tnumtests = 1;\n\tfor ( i=1; argv[i]; ++i ) {\n\t\tif ( strcmp(argv[i], \"-twice\") == 0 ) {\n\t\t\t++numtests;\n\t\t}\n\t\tif ( strcmp(argv[i], \"-logo\") == 0 ) {\n\t\t\tlogo = 1;\n\t\t\tUSE_DEPRECATED_OPENGLBLIT = SDL_FALSE;\n\t\t}\n\t\tif ( strcmp(argv[i], \"-logoblit\") == 0 ) {\n\t\t\tlogo = 1;\n\t\t\tUSE_DEPRECATED_OPENGLBLIT = SDL_TRUE;\n\t\t}\n\t\tif ( strcmp(argv[i], \"-logocursor\") == 0 ) {\n\t\t\tlogocursor = 1;\n\t\t}\n\t\tif ( strcmp(argv[i], \"-slow\") == 0 ) {\n\t\t\tslowly = 1;\n\t\t}\n\t\tif ( strcmp(argv[i], \"-bpp\") == 0 ) {\n \t\t       bpp = atoi(argv[++i]);\n\t\t}\n\t\tif ( strcmp(argv[i], \"-gamma\") == 0 ) {\n \t\t       gamma = (float)atof(argv[++i]);\n\t\t}\n\t\tif ( strcmp(argv[i], \"-noframe\") == 0 ) {\n \t\t       noframe = 1;\n\t\t}\n\t\tif ( strcmp(argv[i], \"-fsaa\") == 0 ) {\n \t\t       ++fsaa;\n\t\t}\n\t\tif ( strcmp(argv[i], \"-accel\") == 0 ) {\n \t\t       ++accel;\n\t\t}\n\t\tif ( strcmp(argv[i], \"-sync\") == 0 ) {\n \t\t       ++sync;\n\t\t}\n\t\tif ( strncmp(argv[i], \"-h\", 2) == 0 ) {\n \t\t       printf(\n\"Usage: %s [-twice] [-logo] [-logocursor] [-slow] [-bpp n] [-gamma n] [-noframe] [-fsaa] [-accel] [-sync] [-fullscreen]\\n\",\n \t\t\t      argv[0]);\n\t\t\texit(0);\n\t\t}\n\t}\n\tfor ( i=0; i<numtests; ++i ) {\n \t\tRunGLTest(argc, argv, logo, logocursor, slowly, bpp, gamma, noframe, fsaa, sync, accel);\n\t}\n\treturn 0;\n}\n\n#else /* HAVE_OPENGL */\n\nint main(int argc, char *argv[])\n{\n\tprintf(\"No OpenGL support on this system\\n\");\n\treturn 1;\n}\n\n#endif /* HAVE_OPENGL */\n"]}