{"version":3,"file":"testnative.c.js","sources":["../SDL-2.0.0/testnative.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsIA;AACA;AAAA;AAAA;AACA;AAAA;;AAEA;AAUA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA1GA;AACA;;AAGA;;AAFA;AAEA","sourcesContent":["/*\n  Copyright (C) 1997-2013 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely.\n*/\n/* Simple program:  Create a native window and attach an SDL renderer */\n\n#include <stdio.h>\n#include <stdlib.h> /* for srand() */\n#include <time.h> /* for time() */\n\n#include \"testnative.h\"\n\n#define WINDOW_W    640\n#define WINDOW_H    480\n#define NUM_SPRITES 100\n#define MAX_SPEED   1\n\nstatic NativeWindowFactory *factories[] = {\n#ifdef TEST_NATIVE_WINDOWS\n    &WindowsWindowFactory,\n#endif\n#ifdef TEST_NATIVE_X11\n    &X11WindowFactory,\n#endif\n#ifdef TEST_NATIVE_COCOA\n    &CocoaWindowFactory,\n#endif\n    NULL\n};\nstatic NativeWindowFactory *factory = NULL;\nstatic void *native_window;\nstatic SDL_Rect *positions, *velocities;\n\n/* Call this instead of exit(), so we can clean up SDL: atexit() is evil. */\nstatic void\nquit(int rc)\n{\n    SDL_VideoQuit();\n    if (native_window) {\n        factory->DestroyNativeWindow(native_window);\n    }\n    exit(rc);\n}\n\nSDL_Texture *\nLoadSprite(SDL_Renderer *renderer, char *file)\n{\n    SDL_Surface *temp;\n    SDL_Texture *sprite;\n\n    /* Load the sprite image */\n    temp = SDL_LoadBMP(file);\n    if (temp == NULL) {\n        fprintf(stderr, \"Couldn't load %s: %s\", file, SDL_GetError());\n        return 0;\n    }\n\n    /* Set transparent pixel as the pixel at (0,0) */\n    if (temp->format->palette) {\n        SDL_SetColorKey(temp, 1, *(Uint8 *) temp->pixels);\n    }\n\n    /* Create textures from the image */\n    sprite = SDL_CreateTextureFromSurface(renderer, temp);\n    if (!sprite) {\n        fprintf(stderr, \"Couldn't create texture: %s\\n\", SDL_GetError());\n        SDL_FreeSurface(temp);\n        return 0;\n    }\n    SDL_FreeSurface(temp);\n\n    /* We're ready to roll. :) */\n    return sprite;\n}\n\nvoid\nMoveSprites(SDL_Renderer * renderer, SDL_Texture * sprite)\n{\n    int sprite_w, sprite_h;\n    int i;\n    SDL_Rect viewport;\n    SDL_Rect *position, *velocity;\n\n    /* Query the sizes */\n    SDL_RenderGetViewport(renderer, &viewport);\n    SDL_QueryTexture(sprite, NULL, NULL, &sprite_w, &sprite_h);\n\n    /* Draw a gray background */\n    SDL_SetRenderDrawColor(renderer, 0xA0, 0xA0, 0xA0, 0xFF);\n    SDL_RenderClear(renderer);\n\n    /* Move the sprite, bounce at the wall, and draw */\n    for (i = 0; i < NUM_SPRITES; ++i) {\n        position = &positions[i];\n        velocity = &velocities[i];\n        position->x += velocity->x;\n        if ((position->x < 0) || (position->x >= (viewport.w - sprite_w))) {\n            velocity->x = -velocity->x;\n            position->x += velocity->x;\n        }\n        position->y += velocity->y;\n        if ((position->y < 0) || (position->y >= (viewport.h - sprite_h))) {\n            velocity->y = -velocity->y;\n            position->y += velocity->y;\n        }\n\n        /* Blit the sprite onto the screen */\n        SDL_RenderCopy(renderer, sprite, NULL, position);\n    }\n\n    /* Update the screen! */\n    SDL_RenderPresent(renderer);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int i, done;\n    const char *driver;\n    SDL_Window *window;\n    SDL_Renderer *renderer;\n    SDL_Texture *sprite;\n    int window_w, window_h;\n    int sprite_w, sprite_h;\n    SDL_Event event;\n\n    if (SDL_VideoInit(NULL) < 0) {\n        fprintf(stderr, \"Couldn't initialize SDL video: %s\\n\",\n                SDL_GetError());\n        exit(1);\n    }\n    driver = SDL_GetCurrentVideoDriver();\n\n    /* Find a native window driver and create a native window */\n    for (i = 0; factories[i]; ++i) {\n        if (SDL_strcmp(driver, factories[i]->tag) == 0) {\n            factory = factories[i];\n            break;\n        }\n    }\n    if (!factory) {\n        fprintf(stderr, \"Couldn't find native window code for %s driver\\n\",\n                driver);\n        quit(2);\n    }\n    printf(\"Creating native window for %s driver\\n\", driver);\n    native_window = factory->CreateNativeWindow(WINDOW_W, WINDOW_H);\n    if (!native_window) {\n        fprintf(stderr, \"Couldn't create native window\\n\");\n        quit(3);\n    }\n    window = SDL_CreateWindowFrom(native_window);\n    if (!window) {\n        fprintf(stderr, \"Couldn't create SDL window: %s\\n\", SDL_GetError());\n        quit(4);\n    }\n    SDL_SetWindowTitle(window, \"SDL Native Window Test\");\n\n    /* Create the renderer */\n    renderer = SDL_CreateRenderer(window, -1, 0);\n    if (!renderer) {\n        fprintf(stderr, \"Couldn't create renderer: %s\\n\", SDL_GetError());\n        quit(5);\n    }\n\n    /* Clear the window, load the sprite and go! */\n    SDL_SetRenderDrawColor(renderer, 0xA0, 0xA0, 0xA0, 0xFF);\n    SDL_RenderClear(renderer);\n\n    sprite = LoadSprite(renderer, \"icon.bmp\");\n    if (!sprite) {\n        quit(6);\n    }\n\n    /* Allocate memory for the sprite info */\n    SDL_GetWindowSize(window, &window_w, &window_h);\n    SDL_QueryTexture(sprite, NULL, NULL, &sprite_w, &sprite_h);\n    positions = (SDL_Rect *) SDL_malloc(NUM_SPRITES * sizeof(SDL_Rect));\n    velocities = (SDL_Rect *) SDL_malloc(NUM_SPRITES * sizeof(SDL_Rect));\n    if (!positions || !velocities) {\n        fprintf(stderr, \"Out of memory!\\n\");\n        quit(2);\n    }\n    srand(time(NULL));\n    for (i = 0; i < NUM_SPRITES; ++i) {\n        positions[i].x = rand() % (window_w - sprite_w);\n        positions[i].y = rand() % (window_h - sprite_h);\n        positions[i].w = sprite_w;\n        positions[i].h = sprite_h;\n        velocities[i].x = 0;\n        velocities[i].y = 0;\n        while (!velocities[i].x && !velocities[i].y) {\n            velocities[i].x = (rand() % (MAX_SPEED * 2 + 1)) - MAX_SPEED;\n            velocities[i].y = (rand() % (MAX_SPEED * 2 + 1)) - MAX_SPEED;\n        }\n    }\n\n    /* Main render loop */\n    done = 0;\n    while (!done) {\n        /* Check for events */\n        while (SDL_PollEvent(&event)) {\n            switch (event.type) {\n            case SDL_WINDOWEVENT:\n                switch (event.window.event) {\n                case SDL_WINDOWEVENT_EXPOSED:\n                    SDL_SetRenderDrawColor(renderer, 0xA0, 0xA0, 0xA0, 0xFF);\n                    SDL_RenderClear(renderer);\n                    break;\n                }\n                break;\n            case SDL_QUIT:\n                done = 1;\n                break;\n            default:\n                break;\n            }\n        }\n        MoveSprites(renderer, sprite);\n    }\n\n    quit(0);\n\n    return 0; /* to prevent compiler warning */\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n"]}